#  DP(Dynamic Programing)


## 간단히 말하자면 점화식이다.
### EX) f(n) = f(n-1) +f(n-2)

## 이 점화식을 푸는 방법은  2가지가 있다.

### 1. Top-Down

F(n)부터 시작해서 F(1)까지 호출하는 방법이다.

이 방법의 경우 , 이제 이미 풀었던 문제를 다시 풀게 될 경우가 발생한다. 

그걸 피하기 위해서는 , 별도의 체크 함수를 두어가지고 , 문제를 풀었으면, 다시 풀지 않도록 해준다.( DFS처럼)

### 2.Bottom-up


F(1)부터 시작해서 , F(n)까지 호출하는 방법이다.

이 방법의 경우 , 처음 부터 차근 차근 풀어나가는 방법이다. 

별도의 저장공간이 필요할 수 있다.


## 문제 : 2017 카카오 코드 예선 보행자 천국


참조 : https://programmers.co.kr/learn/courses/30/lessons/1832


문제 간략 설명: 시작점에서 목표지점까지 갈 수있는 경로의 수를 구하여라  . 자동차는 왼쪽 최상단에서 출발하며, 목표지점은 오른쪽 최하단이다. 자동차는 아래, 오른쪽 방향으로만 움직인다.


     
     

### 해결: 

경로 1개만을 찾는것이 아니기 때문에 DFS는 적합하지 않다. 따라서, 점화식을 새로 세워서 푸는 해결전략이 적합하다.

city_map배열이 주어지는데 , 주어진 city_map배열의 값이 1인경우 해당 좌표로 갈 수있는 경우의 수는 0이고 , 

값이 2이면 , 직진 경로만 포함시킨다.


### 문제 KeyPoint: 
경로의 수를 구할떄 , 오른쪽 진행, 아래쪽 진행을 나눠서 계산해야 한다. 
코딩테스트 특성상 DP를 계산할 때 ,  변수 초기화의 어려움 때문에 , Bottom-up이 좋을거 같다.
